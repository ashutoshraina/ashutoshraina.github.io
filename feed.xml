<rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0"><channel><title /><link>http://ashutoshraina.github.io/feed.xml</link><description /><item><guid isPermaLink="true">http://ashutoshraina.github.io/2014/01/mvc-on-mono-monodevelop/</guid><link>http://ashutoshraina.github.io/2014/01/mvc-on-mono-monodevelop/</link><title>Up and Running with Asp.net MVC Mono and Monodevelop</title><description>&lt;p&gt;After 3 hours worth of work, I was finally able to run Asp.net MVC4 using monodevelop on mono. I will talk about installaing monodevelop later (that was a painful exercise). So, assuming you have monodevelop installed on windows and latest version of mono installed (mono-3.2.3)as well. Now, go file new solution Asp.net MVC project with razor. Run it and wait for the world to fall apart.&lt;/p&gt;

</description><pubDate>Thu, 02 Jan 2014 18:30:00 Z</pubDate><a10:updated>2014-01-02T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;After 3 hours worth of work, I was finally able to run Asp.net MVC4 using monodevelop on mono. I will talk about installaing monodevelop later (that was a painful exercise). So, assuming you have monodevelop installed on windows and latest version of mono installed (mono-3.2.3)as well. Now, go file new solution Asp.net MVC project with razor. Run it and wait for the world to fall apart.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;&lt;img src="http://ashutoshraina.github.io/stylesheets/images/posts/mono-mvc-error.png" alt="Mono MVC Error" /&gt;&lt;/p&gt;

&lt;p&gt;Now, here is the long recipe of fixing it one step at a time. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Go to Project Options -&amp;gt; General -&amp;gt; Change the Target Framework to Mono/.net4.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the Asp.net MVC Nuget package.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://ashutoshraina.github.io/stylesheets/images/posts/nuget-install.png" alt="Nuget Install" /&gt;&lt;/p&gt;

&lt;p&gt;Now, compile and go yayy!!
Press F5 and wait for your happiness to go away.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"Could not launch web server. Make sure that XSP4 web server is installed".
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don't worry it is installed the mono guys just wanted to have fun by poking us with a stick. Copy the &lt;strong&gt;winhack&lt;/strong&gt; folder from &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Program Files (x86)\Mono-3.2.3\lib\mono\4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Program Files (x86)\Mono-3.2.3\lib\mono\4.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was only able to arrive at this hack by looking at the monosoftdebugger source code and a bit of hit and miss. In between I asked around if there was a way to attache IIS Express to monodevelop, I couldn't find anything that was simple and obvious (ended up with a useful IISExpress manager utility, more on that later). If you change the target framework to .net 4 and monitor the application output tab then you will the following and it will make sense as to how I reached winhack folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Loaded assembly: C:\Program Files (x86)\Mono-3.2.3\lib\mono\4.5\winhack\xsp4.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, press F5 again and the misery continues, but thankfully this is something we understand.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.InvalidOperationException
Conflicting versions of ASP.NET Web Pages detected: specified version is "1.0.0.0", but the version in bin is "3.0.0.0". To continue, remove files from the application's bin directory or remove the version specification in web.config.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In project's web.config change the version.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;add key="webpages:Version" value="3.0.0.0" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's press F5 again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.InvalidOperationException
Could not locate Razor Host Factory type: System.Web.Mvc.MvcWebRazorHostFactory, System.Web.Mvc, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the web.config located in the views folder change the version to the appropriate mvc version.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;host factoryType="System.Web.Mvc.MvcWebRazorHostFactory, System.Web.Mvc, Version=5.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Side Note : Better, change the version wherever it needs to be updated.&lt;/p&gt;

&lt;p&gt;Now, Press F5.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://ashutoshraina.github.io/stylesheets/images/posts/mvc-mono-success.png" alt="Success" /&gt;&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/12/tasks-with-timeout-net4.5-contd/</guid><link>http://ashutoshraina.github.io/2013/12/tasks-with-timeout-net4.5-contd/</link><title>Tasks With Timeout On .net 4.5 Contd.</title><description>&lt;p&gt;The previous two posts looked at creating tasks with timeouts on .net4. The code as expected took some heavy lifting to get going. Understanding the extension methods themselves took some time. Today, using .net 4.5 this can be made a lot easier. Can we do better ? Yes we can !!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static Task WithTimeout(this Task task, TimeSpan timeout)
    {
        var delay = task.ContinueWith(t =&amp;gt; { }, new CancellationTokenSource(timeout).Token);
        return Task.WhenAny(task, delay).Unwrap();
    }
    public static Task&amp;lt;T&amp;gt; WithTimeout&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, TimeSpan timeout)
    {            
        var delay = task.ContinueWith(t =&amp;gt; t.Result, new CancellationTokenSource(timeout).Token);
        return Task.WhenAny(task, delay).Unwrap();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</description><pubDate>Sun, 29 Dec 2013 18:30:00 Z</pubDate><a10:updated>2013-12-29T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;The previous two posts looked at creating tasks with timeouts on .net4. The code as expected took some heavy lifting to get going. Understanding the extension methods themselves took some time. Today, using .net 4.5 this can be made a lot easier. Can we do better ? Yes we can !!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static Task WithTimeout(this Task task, TimeSpan timeout)
    {
        var delay = task.ContinueWith(t =&amp;gt; { }, new CancellationTokenSource(timeout).Token);
        return Task.WhenAny(task, delay).Unwrap();
    }
    public static Task&amp;lt;T&amp;gt; WithTimeout&amp;lt;T&amp;gt;(this Task&amp;lt;T&amp;gt; task, TimeSpan timeout)
    {            
        var delay = task.ContinueWith(t =&amp;gt; t.Result, new CancellationTokenSource(timeout).Token);
        return Task.WhenAny(task, delay).Unwrap();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;!--excerpt--&gt;
OK, so that really trimmed the code. Usage still remains the same with one difference. The task will now be really cancelled and not faulted which will force us to change the TaskContinuationOptions to NotOnCanceled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Program
{
    private static List&amp;lt;int&amp;gt; Output = new List&amp;lt;int&amp;gt;();
    private static Random _random = new Random();

    public static int LongRunningTask(string message)
    {
        Console.WriteLine(message);
        Console.WriteLine("Managed thread Id " + Thread.CurrentThread.ManagedThreadId);
        //Simulate a long running task
        Thread.Sleep(TimeSpan.FromSeconds(2));
        var number = _random.Next();
        Console.WriteLine("Adding " + number + " From thread  - " + Thread.CurrentThread.ManagedThreadId);
        return number;
    }
    public static void Main(string[] args)
    {
        Console.WriteLine("In Main");
        TimeoutonNet45();
        Console.ReadLine();
    }

    public static void TimeoutonNet45()
    {
        Console.WriteLine("Managed thread Id " + Thread.CurrentThread.ManagedThreadId);
        var tasks = new List&amp;lt;Task&amp;gt;();
        try
        {
            var t1 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task1"),TaskCreationOptions.AttachedToParent)
                                 .WithTimeout(TimeSpan.FromMilliseconds(1000))                
                                 .ContinueWith(t =&amp;gt; Output.Add(t.Result), TaskContinuationOptions.NotOnCanceled);
            var t2 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task2"), TaskCreationOptions.AttachedToParent)
                                 .ContinueWith(_ =&amp;gt; Output.Add(_.Result));
            tasks.Add(t1);
            tasks.Add(t2);
            Task.WaitAll(tasks.ToArray());
        }
        catch (Exception ex)
        {
            Console.WriteLine("There was an exception");
            Console.WriteLine(ex.InnerException.Message);
        }
        Console.WriteLine("Output :");
        Output.ForEach(_ =&amp;gt; Console.WriteLine(_));
    }

    public static void TimeoutOnNet4()
    {
        Console.WriteLine("Managed thread Id " + Thread.CurrentThread.ManagedThreadId);
        var tasks = new List&amp;lt;Task&amp;gt;();
        try
        {
            var t1 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task1"), TaskCreationOptions.AttachedToParent)
                                 .TimeoutAfter(1000)
                                 .ContinueWith(t =&amp;gt; Output.Add(t.Result), TaskContinuationOptions.NotOnFaulted);
            var t2 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task2"), TaskCreationOptions.AttachedToParent)
                                 .ContinueWith(_ =&amp;gt; Output.Add(_.Result));
            var t3 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task3"), TaskCreationOptions.AttachedToParent)
                                 .ContinueWith(_ =&amp;gt; Output.Add(_.Result));
            tasks.Add(t1);
            tasks.Add(t2);
            tasks.Add(t3);
            Task.WaitAll(tasks.ToArray());
        }
        catch (Exception ex)
        {
            Console.WriteLine("There was an exception");
            Console.WriteLine(ex.InnerException.Message);
        }
        Console.WriteLine("Output :");
        Output.ForEach(_ =&amp;gt; Console.WriteLine(_));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output will look something like this :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In Main
Managed thread Id 10
Entering task1
Managed thread Id 11
Entering task2
Managed thread Id 12
Adding 856463453 From thread  - 12
Adding 1826416296 From thread  - 11
There was an exception
A task was canceled.
Output :
856463453
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A more robust means will always be to check for both faults and cancellation within the continuation. So, this makes creating tasks with timouts a lot easier.&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/12/tasks-with-timeout-contd/</guid><link>http://ashutoshraina.github.io/2013/12/tasks-with-timeout-contd/</link><title>Tasks With Timeout Contd.</title><description>&lt;p&gt;As mentioned in the last post we can now have tasks with individual timeouts. The code looked a little heavy. Can we do better ? Yes we can !!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var tasks = new List&amp;lt;Task&amp;gt;();
    try
    {
    //instead of checking for fault within the continutaion, 
    //we can just use a TaskContinuationOption to tell communicate the right semantics

    var t1 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask(),TaskCreationOptions.AttachedToParent)
    .TimeoutAfter(1000)
    .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult(), 
     TaskContinuationOptions.NotOnFaulted);

    var t2 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask(), TaskCreationOptions.AttachedToParent)
      .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult());

    var t3 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task3"),
    TaskCreationOptions.AttachedToParent)
      .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult());

    tasks.Add(t1);
    tasks.Add(t2);
    tasks.Add(t3);

    Task.WaitAll(tasks.ToArray());
    }
    catch (Exception ex)
    {
    Console.WriteLine("There was an exception");
    Console.WriteLine(ex.InnerException.Message);   
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will show in the next post how this wasn't all that better since this leaves a few gaps.&lt;/p&gt;
</description><pubDate>Mon, 23 Dec 2013 18:30:00 Z</pubDate><a10:updated>2013-12-23T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;As mentioned in the last post we can now have tasks with individual timeouts. The code looked a little heavy. Can we do better ? Yes we can !!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var tasks = new List&amp;lt;Task&amp;gt;();
    try
    {
    //instead of checking for fault within the continutaion, 
    //we can just use a TaskContinuationOption to tell communicate the right semantics

    var t1 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask(),TaskCreationOptions.AttachedToParent)
    .TimeoutAfter(1000)
    .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult(), 
     TaskContinuationOptions.NotOnFaulted);

    var t2 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask(), TaskCreationOptions.AttachedToParent)
      .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult());

    var t3 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task3"),
    TaskCreationOptions.AttachedToParent)
      .ContinueWith(t =&amp;gt; SomethingUsefulWithTheResult());

    tasks.Add(t1);
    tasks.Add(t2);
    tasks.Add(t3);

    Task.WaitAll(tasks.ToArray());
    }
    catch (Exception ex)
    {
    Console.WriteLine("There was an exception");
    Console.WriteLine(ex.InnerException.Message);   
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will show in the next post how this wasn't all that better since this leaves a few gaps.&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/12/tasks-with-timeouts/</guid><link>http://ashutoshraina.github.io/2013/12/tasks-with-timeouts/</link><title>Tasks With Timeout</title><description>&lt;p&gt;So the task is to timeout a task. now, I never thought it would take me as long as it did. Turns out it is a really tricky problem problem. I was expecting something within the framework to make life easier, there isn't anything by default but msdn to the rescue 
&lt;a href="http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx" title="Tasks With Timeout"&gt;Tasks With Timeouts&lt;/a&gt;&lt;/p&gt;

</description><pubDate>Sun, 22 Dec 2013 18:30:00 Z</pubDate><a10:updated>2013-12-22T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;So the task is to timeout a task. now, I never thought it would take me as long as it did. Turns out it is a really tricky problem problem. I was expecting something within the framework to make life easier, there isn't anything by default but msdn to the rescue 
&lt;a href="http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx" title="Tasks With Timeout"&gt;Tasks With Timeouts&lt;/a&gt;&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;So, the extension method is &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static class TaskWithTimeout
{
    internal struct VoidTypeStruct
    { }
    internal static void MarshalTaskResults&amp;lt;TResult&amp;gt;(Task source, TaskCompletionSource&amp;lt;TResult&amp;gt; proxy)
    {
        switch (source.Status)
        {
            case TaskStatus.Faulted:
                proxy.TrySetException(source.Exception);
                break;
            case TaskStatus.Canceled:
                proxy.TrySetCanceled();
                break;
            case TaskStatus.RanToCompletion:
                Task&amp;lt;TResult&amp;gt; castedSource = source as Task&amp;lt;TResult&amp;gt;;
                proxy.TrySetResult(
                    castedSource == null ? default(TResult) : // source is a Task
                        castedSource.Result); // source is a Task&amp;lt;TResult&amp;gt;
                break;
        }
    }

    public static Task TimeoutAfter(this Task task, int millisecondsTimeout)
    {
        // Short-circuit #1: infinite timeout or task already completed
        if (task.IsCompleted || (millisecondsTimeout == Timeout.Infinite))
        {
            // Either the task has already completed or timeout will never occur.
            // No proxy necessary.
            return task;
        }

        // tcs.Task will be returned as a proxy to the caller
        TaskCompletionSource&amp;lt;VoidTypeStruct&amp;gt; tcs = new TaskCompletionSource&amp;lt;VoidTypeStruct&amp;gt;();

        // Short-circuit #2: zero timeout
        if (millisecondsTimeout == 0)
        {
            // We've already timed out.
            tcs.SetException(new TimeoutException());
            return tcs.Task;
        }

        // Set up a timer to complete after the specified timeout period
        Timer timer = new Timer(state =&amp;gt;
        {
            // Recover your state information
            var myTcs = (TaskCompletionSource&amp;lt;VoidTypeStruct&amp;gt;)state;
            // Fault our proxy with a TimeoutException
            myTcs.TrySetException(new TimeoutException());
        }, tcs, millisecondsTimeout, Timeout.Infinite);

        // Wire up the logic for what happens when source task completes
        task.ContinueWith(antecedent =&amp;gt;
                            {
                                timer.Dispose(); // Cancel the timer
                                MarshalTaskResults(antecedent, tcs); // Marshal results to proxy
                            },
                            CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);

        return tcs.Task;
    }

    public static Task&amp;lt;TResult&amp;gt; TimeoutAfter&amp;lt;TResult&amp;gt;(this Task&amp;lt;TResult&amp;gt; task, int millisecondsTimeout)
    {
        // Short-circuit #1: infinite timeout or task already completed
        if (task.IsCompleted || (millisecondsTimeout == Timeout.Infinite))
        {
            // Either the task has already completed or timeout will never occur.
            // No proxy necessary.
            return task;
        }

        // tcs.Task will be returned as a proxy to the caller
        TaskCompletionSource&amp;lt;TResult&amp;gt; tcs = new TaskCompletionSource&amp;lt;TResult&amp;gt;();

        // Short-circuit #2: zero timeout
        if (millisecondsTimeout == 0)
        {
            // We've already timed out.
            tcs.SetException(new TimeoutException());
            return tcs.Task;
        }

        // Set up a timer to complete after the specified timeout period
        Timer timer = new Timer(state =&amp;gt;
                                {
                                    // Recover your state information
                                    var myTcs = (TaskCompletionSource&amp;lt;TResult&amp;gt;)state;
                                    // Fault our proxy with a TimeoutException
                                    myTcs.TrySetException(new TimeoutException());
                                }, tcs, millisecondsTimeout, Timeout.Infinite);

        // Wire up the logic for what happens when source task completes
        task.ContinueWith(antecedent =&amp;gt;
                            {
                                timer.Dispose(); // Cancel the timer
                                MarshalTaskResults(antecedent, tcs); // Marshal results to proxy
                            }, 
                            CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously,TaskScheduler.Default);

        return tcs.Task;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of code for doing this, and the msdn article remains the better source of explanation.&lt;/p&gt;

&lt;p&gt;Now using this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Program
    {
        private static List&amp;lt;int&amp;gt; Output = new List&amp;lt;int&amp;gt;();
        private static Random _random = new Random();

        public static int LongRunningTask(string message)
        {
            Console.WriteLine(message);
            Console.WriteLine("Managed thread Id " + Thread.CurrentThread.ManagedThreadId);
            //Simulate a long running task
            Thread.Sleep(TimeSpan.FromSeconds(2));
            var number = _random.Next();
            Console.WriteLine("Adding " + number + " From thread  - " + Thread.CurrentThread.ManagedThreadId);
            return number;
        }

        public static void Main(string[] args)
        {
            Console.WriteLine("In Main");
            Console.WriteLine("Managed thread Id " + Thread.CurrentThread.ManagedThreadId);
            var cts = new CancellationTokenSource();
            var tasks = new List&amp;lt;Task&amp;gt;();
            try
            {
//In the continuation check for the condition of fault (or something more if you so need) and perform the //continuation
                var t1 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task1"),
                                                    TaskCreationOptions.AttachedToParent)
                                     .TimeoutAfter(1000)
                                     .ContinueWith(antecedent =&amp;gt; {
                        if(!(antecedent.IsCanceled || antecedent.IsFaulted))
                                                         Output.Add(antecedent.Result);
                                }
                                , cts.Token);
                var t2 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task2"),
                                                    TaskCreationOptions.AttachedToParent)
                                     .ContinueWith(_ =&amp;gt; Output.Add(_.Result));
                var t3 = Task.Factory.StartNew(_ =&amp;gt; LongRunningTask("Entering task3"), 
                                                    TaskCreationOptions.AttachedToParent)
                                     .ContinueWith(_ =&amp;gt; Output.Add(_.Result));

                tasks.Add(t1);
                tasks.Add(t2);
                tasks.Add(t3);

                Task.WaitAll(tasks.ToArray());
            }
            catch (Exception ex)
            {                
                Console.WriteLine("There was an exception");
                Console.WriteLine(ex.InnerException.Message);               
            }

            Console.WriteLine("Output :");
            Output.ForEach(_ =&amp;gt; Console.WriteLine(_));

            Console.ReadLine();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important part being that the continuation is applied after the timeout and it won't work with the other way around.
The output therefore basically looks like this : &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In Main
Managed thread Id 9
Entering task1
Managed thread Id 10
Entering task2
Managed thread Id 11
Entering task3
Managed thread Id 14
Adding 194443354 From thread  - 10
Adding 792426557 From thread  - 11
Adding 230130793 From thread  - 14
Output :
792426557
230130793
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, time I will try and write about some other things on Flirting with Tasks.&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/11/mongodb-sharding/</guid><link>http://ashutoshraina.github.io/2013/11/mongodb-sharding/</link><title>MongoDB-Sharding</title><description>&lt;p&gt;&lt;strong&gt;Sharding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mongodb sharding is based on shard key.&lt;/p&gt;

&lt;p&gt;K1 -&amp;gt; k2 on shard1
K2 -&amp;gt; k3 on shard2 etc..&lt;/p&gt;

&lt;p&gt;Each shard is then replicated for higher availability and DR etc..Sharding is therefore range based. Sharding is done per collections basis.Range based sharding helps it do range based queries.&lt;/p&gt;

</description><pubDate>Mon, 04 Nov 2013 18:30:00 Z</pubDate><a10:updated>2013-11-04T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;&lt;strong&gt;Sharding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mongodb sharding is based on shard key.&lt;/p&gt;

&lt;p&gt;K1 -&amp;gt; k2 on shard1
K2 -&amp;gt; k3 on shard2 etc..&lt;/p&gt;

&lt;p&gt;Each shard is then replicated for higher availability and DR etc..Sharding is therefore range based. Sharding is done per collections basis.Range based sharding helps it do range based queries.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;All of the documents on a particular shard are known as chunks ~~ 100mb.&lt;/p&gt;

&lt;p&gt;There are two operations that happen in the background in sharding and these are done automatically for us.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Split - splits a range if the range is producing bigger chunks, this is fairly expensive&lt;/li&gt;
&lt;li&gt;Migrate - moves chunks to somewhere else in the cluster, this is somewhat expensive.
&lt;ul&gt;
&lt;li&gt;Between a pair of shards there will not be more than one migration activity.&lt;/li&gt;
&lt;li&gt;We can still read and write from the data when we are migrating. So, it is live.&lt;/li&gt;
&lt;li&gt;"Balancer" decides when to do the balancing. It balances on the number of chunks today.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Both of these are done to maintain a balance in the shards w.r.t. the documents.
The metadata about these shards and our system is stored in config servers. These are light weight.
Conceptually these shards are processes and not separate physical machines or virtual machines although they can and most likely will be.&lt;/p&gt;

&lt;p&gt;Mongos gives the client the big picture of the whole setup. Client is therefore insulated from the underlying architecture that is used to implement sharding, replication etc..&lt;/p&gt;

&lt;p&gt;&lt;img src="http://ashutoshraina.github.io/stylesheets/images/posts/sharding.png" alt="Sharding" /&gt;&lt;/p&gt;

&lt;p&gt;End client applications should go through mongos.&lt;/p&gt;

&lt;p&gt;To create a shard connect to mongos&lt;/p&gt;

&lt;p&gt;Then&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh.addShard("hostname:port")
sh.enableSharding("dbname")
db.ensureIndex(Key pattern for your shard key)
sh.shardCollection("namespaceforyourCollection",shardkey);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choosing a shard key&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Filed should be involved in most of the queries&lt;/li&gt;
&lt;li&gt;Good cardinality/granularity&lt;/li&gt;
&lt;li&gt;Shard key should not increase monotonically&lt;/li&gt;
&lt;/ul&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/11/mongodb-replication/</guid><link>http://ashutoshraina.github.io/2013/11/mongodb-replication/</link><title>MongoDB-Replication</title><description>&lt;p&gt;&lt;strong&gt;REPLICATION&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Replication helps us achieve availability and fault-tolerance. A replica set is a set of mongo nodes that replicate data amongst each other asynchronously. One of the replica sets is primary while the rest of them will be secondary.
Writes only happen to the primary. If the primary goes down then an election happens and the new primary comes up.
Minimum number of nodes will be 3, since the election requires a majority of the original set.
If there were only 2 sets then the remaining one is not a majority and you would not be able to write.&lt;/p&gt;

&lt;p&gt;</description><pubDate>Sun, 03 Nov 2013 18:30:00 Z</pubDate><a10:updated>2013-11-03T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;&lt;strong&gt;REPLICATION&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Replication helps us achieve availability and fault-tolerance. A replica set is a set of mongo nodes that replicate data amongst each other asynchronously. One of the replica sets is primary while the rest of them will be secondary.
Writes only happen to the primary. If the primary goes down then an election happens and the new primary comes up.
Minimum number of nodes will be 3, since the election requires a majority of the original set.
If there were only 2 sets then the remaining one is not a majority and you would not be able to write.&lt;/p&gt;

&lt;p&gt;&lt;!--excerpt--&gt;
Replica Set Elections&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Regular Node : It has the data and can become primary or secondary.
Arbiter : It is just there for voting purposes. We need it if we want an even number of nodes. It has no data on it.
Delayed/Regular : It can be set to a few hours after the nodes. It cannot become primary. It's priority is set to 0.
Hidden Node : It cannot become a primary node. It's priority is set to 0.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the reads and writes go to the primary. You can go to secondary for reading. This means that you might read stale data. The lag between nodes is not guaranteed since the process is async. If you read from secondary then what we have is &lt;em&gt;"eventual consistency"&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rs.slaveOk() -- ok to read from the secondary
rs.isMaster() -- checks whether the node is master
rs.status() -- gives the current status of the replica set.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the database locals , the collection oplogs.rs has all the operational logs. Replication happens when secondary nodes query the primary for the changes from a given timestamp. OpLog is the statement based replication log.
Replication happens in a statement driven manner?
e.g If a statement deletes 100 documents on the primary then there will 100 statements that are sent to the secondary to execute. There is no binary replication. This allows us to run different version of mongodb on different machines.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try to keep the OpLog small on 64 bit machine since it defaults to a large value on 64 bit systems.&lt;/li&gt;
&lt;li&gt;For replica sets don't use localhost or the ip address of the machine.&lt;/li&gt;
&lt;li&gt;Use a logical name, that is the best practice.&lt;/li&gt;
&lt;li&gt;Use DNS.&lt;/li&gt;&lt;/li&gt;
&lt;li&gt;Pick appropriate TTL as well.&lt;/li&gt;
&lt;/ul&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/10/review-csharp-indepth/</guid><link>http://ashutoshraina.github.io/2013/10/review-csharp-indepth/</link><title>Review-CSharp in Depth.</title><description>&lt;p&gt;I have read the second edition as well. The third edition carries on from there and provides a deeper look in C# 5 and it's key feature async/await. If you want to understand what goes on behind the scenes, this one is for you. Jon Skeet ( yes the famous guy &lt;a href="http://stackoverflow.com/users/22656/jon-skeet" title="Jon Skeet"&gt;Jon Skeet&lt;/a&gt;) has managed to come out with a great book once again.&lt;/p&gt;

</description><pubDate>Tue, 22 Oct 2013 18:30:00 Z</pubDate><a10:updated>2013-10-22T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;I have read the second edition as well. The third edition carries on from there and provides a deeper look in C# 5 and it's key feature async/await. If you want to understand what goes on behind the scenes, this one is for you. Jon Skeet ( yes the famous guy &lt;a href="http://stackoverflow.com/users/22656/jon-skeet" title="Jon Skeet"&gt;Jon Skeet&lt;/a&gt;) has managed to come out with a great book once again.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Jon starts easy on this, but doesn't hold back. The prose is lucid yet well paced. It is one of the few books that make the effort to take the reader on journey. The journey begins with C#1 and then continues to C#5. Hardly any chapters drag on anymore than they should. Linq is covered in great depth and is a nicely written with enough diagrams to visualize what is happening under the hood. Generics is one my personal favourites. The text is nice, so are the code samples. I have never really understood generics completely, but the books does make things a lot clearer. The treatment of dynamic is really nice. It goes into the heart of the DLR and shows everything that you need to know to really understand dynamic. &lt;/p&gt;

&lt;p&gt;The book really shines when you move to &lt;em&gt;async/await&lt;/em&gt;. Jon makes a rather tough concept easier. I had to read it several times but each time the concept became easier. I only wish we moved away from the download the web page example for async. The book does spend time on compiler transformations that are behind &lt;em&gt;async/await&lt;/em&gt;. Be patient when you read it, it will take time to sink in.&lt;/p&gt;

&lt;p&gt;The only part that has been left out from the third edition is the chapter on Code Contracts. Jon clearly mentions that the topic hasn't gained as much traction as he hoped. It may come back in the future though. As many have mentioned this before this is not a book for beginners. Use this to become a better C# programmer, after you have written C# for some time. This is a must have in your collection, especially if you work with C# day in and day out. It will give you a greater understanding of how the language designers wanted you think, and what makes C# a real joy.
A 4.5/5 for this one, keeping the 0.5 for the next edition :).&lt;/p&gt;

&lt;p&gt;P.S. Even the appendix is handy.&lt;/p&gt;

&lt;p&gt;Disclosure : I got a free copy of the book to review.  The review is my own opinion and not influenced by anyone else.&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/10/mongodb-understanding-your-queries-through-explainplan/</guid><link>http://ashutoshraina.github.io/2013/10/mongodb-understanding-your-queries-through-explainplan/</link><title>MongoDB-Understanding queries through explain plan</title><description>&lt;p&gt;Understanding the queries we write is very critical and MongoDB does a good job here. Developers will find it easy to understand what the queries are doing and where to look for bottlenecks. Well defined parameters and also well documented ones make life a lot easier.
The details have been taken from the mongodb website and presented here for continuity of series.&lt;/p&gt;

</description><pubDate>Sat, 12 Oct 2013 18:30:00 Z</pubDate><a10:updated>2013-10-12T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;Understanding the queries we write is very critical and MongoDB does a good job here. Developers will find it easy to understand what the queries are doing and where to look for bottlenecks. Well defined parameters and also well documented ones make life a lot easier.
The details have been taken from the mongodb website and presented here for continuity of series.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;&lt;strong&gt;Explain Output Fields&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.cursor&lt;/em&gt;
cursor is a string that reports the type of cursor used by the query operation:&lt;/p&gt;

&lt;p&gt;BasicCursor indicates a full collection scan.
BtreeCursor indicates that the query used an index. The cursor includes name of the index. When a query uses an index, the output of explain() includes indexBounds details.
GeoSearchCursor indicates that the query used a geospatial index.
explain.isMultiKey
isMultiKey is a boolean. When true, the query uses a multikey index, where one of the fields in the index holds an array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.n&lt;/em&gt;
n is a number that reflects the number of documents that match the query selection criteria.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.nscannedObjects&lt;/em&gt;
Specifies the total number of documents scanned during the query. The nscannedObjects may be lower than nscanned, such as if the index covers a query. See indexOnly. Additionally, the nscannedObjects may be lower than nscanned in the case of multikey index on an array field with duplicate documents.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.nscanned&lt;/em&gt;
Specifies the total number of documents or index entries scanned during the database operation. You want n and nscanned to be close in value as possible. The nscanned value may be higher than the nscannedObjects value, such as if the index covers a query. See indexOnly.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.nscannedObjectsAllPlans&lt;/em&gt;
nscannedObjectsAllPlans is a number that reflects the total number of documents scanned for all query plans during the database operation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.nscannedAllPlans&lt;/em&gt;
nscannedAllPlans is a number that reflects the total number of documents or index entries scanned for all query plans during the database operation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.scanAndOrder&lt;/em&gt;
scanAndOrder is a boolean that is true when the query cannot use the index for returning sorted results.&lt;/p&gt;

&lt;p&gt;When true, MongoDB must sort the documents after it retrieves them from either an index cursor or a cursor that scans the entire collection.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.indexOnly&lt;/em&gt;
indexOnly is a boolean value that returns true when the query is covered by the index indicated in the cursor field. When an index covers a query, MongoDB can both match the query conditions and return the results using only the index because:&lt;/p&gt;

&lt;p&gt;all the fields in the query are part of that index, and
all the fields returned in the results set are in the same index.
explain.nYields
nYields is a number that reflects the number of times this query yielded the read lock to allow waiting writes execute.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.nChunkSkips&lt;/em&gt;
nChunkSkips is a number that reflects the number of documents skipped because of active chunk migrations in a sharded system. Typically this will be zero. A number greater than zero is ok, but indicates a little bit of inefficiency.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.millis&lt;/em&gt;
millis is a number that reflects the time in milliseconds to complete the query.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.indexBounds&lt;/em&gt;
indexBounds is a document that contains the lower and upper index key bounds. This field resembles one of the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"indexBounds" : {
"start" : {  : , ...  },
"end" : {  : , ... }
},
"indexBounds" : { "" : [ [ ,  ] ],
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;explain.allPlans&lt;/em&gt;
allPlans is an array that holds the list of plans the query optimizer runs in order to select the index for the query. Displays only when the  parameter to explain() is true or 1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.oldPlan&lt;/em&gt;
oldPlan is a document value that contains the previous plan selected by the query optimizer for the query. Displays only when the  parameter to explain() is true or 1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.server&lt;/em&gt;
server is a string that reports the MongoDB server.&lt;/p&gt;

&lt;p&gt;$or Query Output Fields
explain.clauses
clauses is an array that holds the Core Explain Output Fields information for each clause of the $or expression. clauses is only included when the clauses in the $or expression use indexes.&lt;/p&gt;

&lt;p&gt;Sharded Collections Output Fields
&lt;em&gt;explain.clusteredType&lt;/em&gt;
clusteredType is a string that reports the access pattern for shards. The value is:&lt;/p&gt;

&lt;p&gt;ParallelSort, if the mongos queries shards in parallel.
SerialServer, if the mongos queries shards sequentially.
&lt;em&gt;explain.shards&lt;/em&gt;
shards contains fields for each shard in the cluster accessed during the query. Each field holds the Core Explain Output Fields for that shard.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.millisShardTotal&lt;/em&gt;
millisShardTotal is a number that reports the total time in milliseconds for the query to run on the shards.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.millisShardAvg&lt;/em&gt;
millisShardAvg is a number that reports the average time in millisecond for the query to run on each shard.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.numQueries&lt;/em&gt;
numQueries is a number that reports the total number of queries executed.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;explain.numShards&lt;/em&gt;
numShards is a number that reports the total number of shards queried.&lt;/p&gt;

&lt;p&gt;Lastly, some more profiling tips that can be pretty useful.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Logging Slow Queries&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are 3 levels for the profiler 0 OFF , 1Slow, 2 ALL&lt;/li&gt;
&lt;li&gt;Enable this using mongod -profile 1 --slowms 2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Db.getProfilingLevel()&lt;/code&gt; to get the current profiling level.&lt;/li&gt;
&lt;li&gt;If you want to get all queries that took longer than 3 second, ordered by timestamp descending&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.system.profile.find({millis:{$gt:3000}}).sort({ts:-1})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mongotop can be run set to a specific time interval to determine where is the majority of the time spent. This utility tracks the time that mongod spends on reads and writes. The information is on a per collection basis.
I prefer to increase the time for reporting from the default 1 sec to somewhere close to 5 sec or more (this is just a random number that I feel comfortable with..otherwise the data is to verbose to make any sense).&lt;/p&gt;

&lt;p&gt;This should be a good start. We will go into some more concepts about monitoring mongodb before going into sharding etc..&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/10/mongodb-indexing/</guid><link>http://ashutoshraina.github.io/2013/10/mongodb-indexing/</link><title>MongoDB-Indexing</title><description>&lt;p&gt;Indexing is one of the most important concepts for any database. Without indexes the mongod process would scan the entire collection and the all the documents it contains to obtain the result of the query. Indexes are defined for the collections and properties as well as sub-fields are supported. Briefly, MongoDB supports the following types of indexes : &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single Field Indexes&lt;/strong&gt; : Think about having an index on a column in RDBMS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compound Indexes&lt;/strong&gt;: Think about an having an index on multiple columns in RDBMS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multikey Indexes&lt;/strong&gt;: This is unique to MongodB, it references an array and succeeds if there is a match for any value in the array.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geospatial Indexes and Queries&lt;/strong&gt; : Allows you to index GeoData. I really don't know much about this to comment. MongoDB website is the best source.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text Indexes&lt;/strong&gt; : For full text search inside a document. Should we use lucene ? Not sure ?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hashed Index&lt;/strong&gt;: Index on hashed contents of the fields.&lt;/li&gt;
&lt;/ul&gt;

</description><pubDate>Sat, 05 Oct 2013 18:30:00 Z</pubDate><a10:updated>2013-10-05T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;Indexing is one of the most important concepts for any database. Without indexes the mongod process would scan the entire collection and the all the documents it contains to obtain the result of the query. Indexes are defined for the collections and properties as well as sub-fields are supported. Briefly, MongoDB supports the following types of indexes : &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single Field Indexes&lt;/strong&gt; : Think about having an index on a column in RDBMS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compound Indexes&lt;/strong&gt;: Think about an having an index on multiple columns in RDBMS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multikey Indexes&lt;/strong&gt;: This is unique to MongodB, it references an array and succeeds if there is a match for any value in the array.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geospatial Indexes and Queries&lt;/strong&gt; : Allows you to index GeoData. I really don't know much about this to comment. MongoDB website is the best source.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text Indexes&lt;/strong&gt; : For full text search inside a document. Should we use lucene ? Not sure ?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hashed Index&lt;/strong&gt;: Index on hashed contents of the fields.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Indexes have properties associated with them :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TTL: This is a rather surprising feature. I never expected such a feature to be available on indexes, but after giving it some thought, it makes sense to expire the indexes.&lt;/li&gt;
&lt;li&gt;Unique: Only documents with unique values on the field are permitted.&lt;/li&gt;
&lt;li&gt;Sparse: Really useful if you are going to have sparse fields. It leaves out the documents that do not have the field.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Some more tid-bits&lt;/strong&gt;
- The order of indexes matters.
e.g. if an index is created on (a,b,c) then index will be used only if the query is on
- A or a,b or a,b,c . 
- Index will not be called if we query on b,c or c.
- It needs to be a left subset of the index.&lt;/p&gt;

&lt;p&gt;The command is below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Db.collection.ensureIndex('property');
e.g. `db.students.ensureIndex({'class':1,'student_name':1});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- Note: 1 or -1 is for ascending v/s descending which becomes useful when we have a lot of sort queries.
- By default all the indexes are built in the foreground i.e. all the writers will be blocked while the index is being created. It is fast but the database is blocked.
- Background ones are slow, fit for production use.
- Creating the database index in the background also blocks the current shell while it is being created.
- All indexes are Btree indexes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Index Creation option , Unique , Removing Duplicates&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unique indexes ensure that the key is unique in the collection.&lt;/li&gt;
&lt;li&gt;e.g. db.students.ensureIndex({'student&lt;em&gt;id':1,'class&lt;/em&gt;id':1},{'unique':true})&lt;/li&gt;
&lt;li&gt;To remove the duplicates while creating the index we can do the following :&lt;/li&gt;
&lt;li&gt;Provide the dropDups :true along with the unique attribute. This is dangerous, so handle with care. There is no way to control which documents it will remove. It will let live a single document and we can't predict or configure as to which one it will be.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;MultiKey Index&lt;/em&gt;
- It will create an index for all the items in the array if the key.
- You can't have two multi keys in a single index. This cause a polynomial explosion of the indexes.
- We will only when we first insert something in the collection.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Index Efficiency&lt;/em&gt;
- $gt, $lt will use the index but the efficiency may not be there since the selectivity could be very low.
Similar for $ne etc.. &lt;/p&gt;

&lt;p&gt;&lt;em&gt;Index Size&lt;/em&gt;
- Indexes must be kept in memory.
- Db.collection.stats() to get the stats on the collection.
Db.collection.getIndexSize() to get the total size of the index of the database.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Final thoughts&lt;/strong&gt;
- Create any and all indexes that are required for your queries.
- Ensure that the indexes fit in memory, reading from the disk is bad.
- Sorting should also use Indexes.
- High selectivity should be the prime consideration when deciding about indexes.&lt;/p&gt;
</a10:content></item><item><guid isPermaLink="true">http://ashutoshraina.github.io/2013/10/mongodb-ops-stuff/</guid><link>http://ashutoshraina.github.io/2013/10/mongodb-ops-stuff/</link><title>MongoDB-Ops-Stuff</title><description>&lt;p&gt;In the previous two posts we have seen some basic querying and how to leverage the querying mechanism to get up and running. Now, we are off in the wild world and we also need to some more complicated stuff.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Creating Indexes&lt;/strong&gt;
The api surface is really smooth with this, allowing us to specify the sort order of the indexes and the manner of building them foreground or background.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void CreateIndex()
{
var QuestionConnectionHandler = new MongoConnectionHandler&amp;lt;Question&amp;gt;("MongoDBDemo");
QuestionConnectionHandler.MongoCollection.EnsureIndex( 
                      IndexKeys.Ascending("Difficulty"), IndexOptions.SetBackground(true));
}
&lt;/code&gt;&lt;/pre&gt;

</description><pubDate>Fri, 04 Oct 2013 18:30:00 Z</pubDate><a10:updated>2013-10-04T18:30:00Z</a10:updated><a10:content type="text">&lt;p&gt;In the previous two posts we have seen some basic querying and how to leverage the querying mechanism to get up and running. Now, we are off in the wild world and we also need to some more complicated stuff.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Creating Indexes&lt;/strong&gt;
The api surface is really smooth with this, allowing us to specify the sort order of the indexes and the manner of building them foreground or background.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void CreateIndex()
{
var QuestionConnectionHandler = new MongoConnectionHandler&amp;lt;Question&amp;gt;("MongoDBDemo");
QuestionConnectionHandler.MongoCollection.EnsureIndex( 
                      IndexKeys.Ascending("Difficulty"), IndexOptions.SetBackground(true));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--excerpt--&gt;

&lt;p&gt;Dropping indexes is also easy with &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QuestionConnectionHandler.MongoCollection.DropAllIndexes();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens when you want to see what is going on under the hood ? You let the database &lt;strong&gt;Explain&lt;/strong&gt; it's&lt;strong&gt; Plan&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QuestionConnectionHandler.MongoCollection.AsQueryable()
                  .Where(q =&amp;gt; q.Difficulty &amp;gt;= 3).Explain();
//or if you went the other way 
var query = Query&amp;lt;Question&amp;gt;.GTE(q =&amp;gt; q.Difficulty, 3);
var explainPlan = QuestionConnectionHandler.MongoCollection
                          .FindAs&amp;lt;Question&amp;gt;(query).Explain();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if only we could have some stats about our database and the indexes. All wrapped in a nice syntax.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stats = QuestionConnectionHandler.MongoCollection.GetStats();
Console.WriteLine("Namespace : {0}", stats.Namespace);
Console.WriteLine("DataSize : {0}", stats.DataSize);
Console.WriteLine("Index Count : {0}", stats.IndexCount);
stats.IndexSizes.Keys.ForEach(Console.WriteLine);
var size = QuestionConnectionHandler.MongoCollection.GetTotalDataSize();
Console.WriteLine("The total datasize for this collection is {0}", size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A routine task is to get all the collections in a database and all the databases on the server itself. Easy peasy!!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var collections = QuestionConnectionHandler.MongoCollection.Database.GetCollectionNames();
Console.WriteLine("\nThe following collections are present in the database");
collections.ForEach(Console.WriteLine);
var client = new MongoClient(@"mongodb://localhost");
var server = client.GetServer();
var databases = server.GetDatabaseNames().ToList();
Console.WriteLine("\nAll the databases in the server");
databases.ForEach(Console.WriteLine);
&lt;/code&gt;&lt;/pre&gt;
</a10:content></item></channel></rss>